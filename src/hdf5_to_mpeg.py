# -*- coding: utf-8 -*-
"""
.. warning::
    ffmpeg is required for this program.
    Please make sure before using hdf5_to_mpeg that ffmpeg is installed on your system.

:Parameters:
    **hdf5 path** â€” As command line parameter the path to hdf5 of the simulation is required.

hdf5_to_mpeg is a tool to make a video from a hdf5 file
generated by the Lattice Boltzmann Simulation code kaLB.

This tool helps you to make a video out of a simulation.
In the process, images are created using matplotlib
and videos are created from the images using ffmpeg.
To speed up the process of creating images, multithreading is used.
From the hdf5 files the density and the speed are read out
and displayed in two independent videos.
The plot settings are adapted for the kaLB example simulation
and can be customized in the code for the desired problem.
"""

import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
from multiprocessing import Pool
import numpy as np
import argparse
import h5py
import os

# Set plot layout and higher resolution
plt.style.use('bmh')
plt.rcParams['figure.figsize'] = (16.0, 9.0)


def parse_arguments():
    """
    Parse commandline arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-i', '--input', required=True, type=str,
        help="Specify path to input hdf5 file."
    )
    return parser.parse_args()


def make_density_pictures(number):
    """
    The plot command for the density
    At this point you can change the settings for the plot.
    :param number: number of the picture to be made. The pictures are listed with ascending number.
    """
    plt.imshow(np.array(density_values[number]).T, origin="lower")
    plt.title("t = %i" % velocity_names[number])
    plt.xlabel("x")
    plt.ylabel("y")
    plt.tight_layout()
    plt.savefig("./temp_png_to_mp4/density_%i.png" % number)
    plt.cla()


def make_velocity_pictures(number):
    """
    The plot command for the speed
    At this point you can change the settings for the plot.
    :param number: number of the picture to be made. The pictures are listed with ascending number.
    """
    plt.imshow(np.sqrt(np.array(velocity_values[number][0]) ** 2 +
                       np.array(velocity_values[number][1]) ** 2).T,
               norm=LogNorm(vmin=1e-3, vmax=1e-1), origin="lower")
    plt.title("t = %i" % velocity_names[number])
    plt.xlabel("x")
    plt.ylabel("y")
    plt.tight_layout()
    plt.savefig("./temp_png_to_mp4/velocity_%i.png" % number)
    plt.cla()


# security check so that no files are overwritten
if os.path.isfile("clip_density.mp4"):
    print("file clip_density.mp4 already exists. Please rename it and start again.")
    quit()
if os.path.isfile("clip_velocity.mp4"):
    print("file clip_velocity.mp4 already exists. Please rename it and start again.")
    quit()

# hdf5 file is read.
args = parse_arguments()
f = h5py.File(args.input, 'r')
a_group_key = list(f.keys())

# Values are read for the density and for speed and names are given.
if 'raw data output configuration' in a_group_key:

    if 'density' in list(f['raw data output configuration']):
        density_values = []
        density_names = list(f['raw data output configuration']['density'])
        for i, name in enumerate(density_names):
            density_names[i] = int(name)
        for i in f['raw data output configuration']['density']:
            density_values.append(f['raw data output configuration']['density'][i])
        density_values = [x for y, x in sorted(zip(density_names, density_values))]
        density_names.sort()

    if 'velocity' in list(f['raw data output configuration']):
        velocity_values = []
        velocity_names = list(f['raw data output configuration']['velocity'])
        for i, name in enumerate(velocity_names):
            velocity_names[i] = int(name)
        for i in f['raw data output configuration']['velocity']:
            velocity_values.append(f['raw data output configuration']['velocity'][i])
        velocity_values = [x for y, x in sorted(zip(velocity_names, velocity_values))]
        velocity_names.sort()

# a folder for the images is created temporarily
if not os.path.exists("temp_png_to_mp4"):
    os.makedirs("temp_png_to_mp4")

# images are created in parallel
pool = Pool()
print("\n Start building density pictures: 0% done \n")
pool.map(make_density_pictures, range(len(density_values)))
print("\n Start building velocity pictures: 40% done \n")
pool.map(make_velocity_pictures, range(len(velocity_values)))

# images are processed into videos
if os.path.isfile("clip_density.mp4"):
    print("file clip_density.mp4 already exists. Please rename it and start again.")
else:
    print("\n Start building density video: 80% done \n")
    os.system(
        "ffmpeg -r 30 -i ./temp_png_to_mp4/density_%01d.png -vb 10M ./clip_density.mp4")
if os.path.isfile("clip_velocity.mp4"):
    print("file clip_velocity.mp4 already exists. Please rename it and start again.")
else:
    print("\n Start building velocity video: 90% done \n")
    os.system(
        "ffmpeg -r 30 -i ./temp_png_to_mp4/velocity_%01d.png -vb 10M ./clip_velocity.mp4")

# Delete the images and the temporary folder
for root, dirs, files in os.walk("temp_png_to_mp4", topdown=False):
    for name in files:
        os.remove(os.path.join(root, name))
os.rmdir("temp_png_to_mp4")
print("\n Everything ready: 100% done \n")
